#|
This file is a part of aoc-2022
(c) 2022 Janne Pakarinen (gingeralesy@gmail.com)
Author: Janne Pakarinen <gingeralesy@gmail.com>
|#

(in-package #:aoc-2022)

(defparameter *day17-rocks*
  (list (make-array '(1 4) :element-type 'boolean :initial-contents '((T T T T)))
        (make-array '(3 3) :element-type 'boolean :initial-contents '((NIL T NIL)
                                                                      ( T  T  T )
                                                                      (NIL T NIL)))
        (make-array '(3 3) :element-type 'boolean :initial-contents '((NIL NIL  T )
                                                                      (NIL NIL  T )
                                                                      ( T   T   T )))
        (make-array '(4 1) :element-type 'boolean :initial-contents '((T) (T) (T) (T)))
        (make-array '(2 2) :element-type 'boolean :initial-contents '((T T) (T T)))))

(defun day17-print-rock (rock)
  (dotimes (row (array-dimension rock 0))
    (dotimes (col (array-dimension rock 1))
      (format T "~c" (if (aref rock row col) #\# #\.)))
    (format T "~%")))

(defun day17-print-field (field height &optional rock rock-x rock-y)
  (loop with rock-height = (if rock (array-dimension rock 0) 0)
        with rock-width = (if rock (array-dimension rock 1) 0)
        for row from (- (array-dimension field 0) (1+ height)) below (array-dimension field 0)
        for rock-row = (and rock (- row rock-y))
        do (format T "|")
        do (dotimes (col (array-dimension field 1))
             (let ((rock-col (and rock (- col rock-x))))
               (format T "~c"
                       (cond
                         ((and rock
                               (<= 0 rock-row) (< rock-row rock-height)
                               (<= 0 rock-col) (< rock-col rock-width)
                               (aref rock rock-row rock-col))
                          #\@)
                         ((aref field row col) #\#)
                         (T #\.)))))
        do (format T "|~%"))
  (format T "+")
  (dotimes (i (array-dimension field 1))
    (format T "-"))
  (format T "+~%"))

(defun day17-parse-input ()
  (with-open-file (stream (input 17) :if-does-not-exist :error)
    (loop for dir = (case (read-char stream NIL :eof)
                      (#\< -1)
                      (#\> +1)
                      (:eof (return-from day17-parse-input dirs)))
          when dir collect dir into dirs)))


(defun day17-copy-field (from to)
  (let* ((width (array-dimension from 1))
         (old-height (array-dimension from 0))
         (new-height (array-dimension to 0))
         (offset (- new-height old-height)))
    (unless (= width (array-dimension to 1))
      (error "Different widths!"))
    (unless (<= old-height new-height)
      (error "Cannot shrink heights!"))
    (dotimes (row old-height)
      (dotimes (col (array-dimension to 1))
        (setf (aref to (+ row offset) col) (aref from row col))))))

(defun day17-puzzle1 (&optional (count 2022))
  (let* ((field-width 7)
         (field-height 1024)
         (field (make-array (list field-height field-width)
                            :element-type 'boolean :initial-element NIL))
         (height 0)
         (all-moves (day17-parse-input))
         (next-move all-moves)
         (next-rock *day17-rocks*))
    (flet ((move (&optional peek)
             (let ((move (car next-move)))
               (unless peek (setf next-move (or (cdr next-move) all-moves)))
               move))
           (rock ()
             (let ((rock (car next-rock)))
               (setf next-rock (or (cdr next-rock) *day17-rocks*))
               rock))
           (collides-p (rock x y)
             (let ((rock-height (array-dimension rock 0))
                   (rock-width (array-dimension rock 1)))
               (when (or (< x 0) (< field-width (+ x rock-width))
                         (< field-height (+ y rock-height)))
                 (return-from collides-p T))
               (when (< y 0) (error "Field overflow!"))
               (dotimes (row rock-height)
                 (dotimes (col rock-width)
                   (when (and (aref rock row col) (aref field (+ y row) (+ x col)))
                     (return-from collides-p T))))))
           (land (rock x y)
             (dotimes (row (array-dimension rock 0))
               (dotimes (col (array-dimension rock 1))
                 (when (aref rock row col)
                   (when (aref field (+ y row) (+ x col))
                     (error "Overlap! ~a,~a" x y))
                   (setf (aref field (+ y row) (+ x col)) T))))))
      (dotimes (i count)
        (let* ((rock (rock))
               (y (- field-height (+ height 3 (array-dimension rock 0))))
               (x 2))
          ;; (day17-print-rock rock)
          (loop for move = (move)
                ;; do (day17-print-field field 6 rock x y)
                unless (collides-p rock (+ x move) y) do (incf x move)
                ;; do (day17-print-field field 6 rock x y)
                do (incf y)
                until (collides-p rock x y)
                finally (progn
                          (land rock x (1- y))
                          (setf height (max height (- field-height (1- y))))
                          (when (< (- field-height height) 16)
                            (let* ((new-field-height (* 2 field-height))
                                   (new-field (make-array (list new-field-height field-width)
                                                          :element-type 'boolean
                                                          :initial-element NIL)))
                              (day17-copy-field field new-field)
                              (setf field new-field)
                              (setf field-height new-field-height))))))))
    (day17-print-field field (max 6 height))
    height))

;; 3224
